diff --git a/client/client.go b/client/client.go
index 4ebccbe..ba1cee6 100644
--- a/client/client.go
+++ b/client/client.go
@@ -131,7 +131,7 @@ func (c *Client) OnBitmap(f func([]Bitmap)) {
 		f(bs)
 	}
 
-	c.ctl.On("update", f1)
+	c.ctl.On("bitmap", f1)
 }
 
 type Bitmap struct {
@@ -146,24 +146,8 @@ type Bitmap struct {
 	Data         []byte `json:"data"`
 }
 
-func Bpp(bp uint16) (pixel int) {
-	switch bp {
-	case 15:
-		pixel = 1
-
-	case 16:
-		pixel = 2
-
-	case 24:
-		pixel = 3
-
-	case 32:
-		pixel = 4
-
-	default:
-		glog.Error("invalid bitmap data format")
-	}
-	return
+func Bpp(bp uint16) int {
+	return int(bp / 8)
 }
 
 type Setting struct {
diff --git a/client/client_test.go b/client/client_test.go
index f69f467..0858a52 100644
--- a/client/client_test.go
+++ b/client/client_test.go
@@ -14,7 +14,7 @@ func TestClient(t *testing.T) {
 		fmt.Println("Login:", err)
 	}
 	c.OnBitmap(func(b []Bitmap) {
-		fmt.Println("ready:", b)
+		fmt.Println("ready")
 	})
 	time.Sleep(100 * time.Second)
 }
diff --git a/client/rdp.go b/client/rdp.go
index 145b1aa..8a8e8ce 100644
--- a/client/rdp.go
+++ b/client/rdp.go
@@ -60,7 +60,7 @@ func (c *RdpClient) Login(host, user, pwd string, width, height int) error {
 	c.pdu = pdu.NewClient(c.sec)
 	c.channels = plugin.NewChannels(c.sec)
 
-	c.mcs.SetClientCoreData(uint16(width), uint16(height))
+	c.mcs.SetClientDesktop(uint16(width), uint16(height))
 
 	c.sec.SetUser(user)
 	c.sec.SetPwd(pwd)
diff --git a/core/socket.go b/core/socket.go
index 31b2f86..875a5ec 100644
--- a/core/socket.go
+++ b/core/socket.go
@@ -9,7 +9,6 @@ import (
 	//"crypto/tls"
 	"errors"
 	"net"
-
 	"github.com/icodeface/tls"
 )
 
diff --git a/example/example.exe b/example/example.exe
index ccf97a8..3291c33 100644
Binary files a/example/example.exe and b/example/example.exe differ
diff --git a/example/main.go b/example/main.go
index 31ce666..dc196be 100644
--- a/example/main.go
+++ b/example/main.go
@@ -32,7 +32,7 @@ func main() {
 		socketIO()
 	} else {
 		//client example
-		StartUI(1024, 768)
+		StartUI(1520, 1080)
 	}
 }
 
diff --git a/example/rdp.go b/example/rdp.go
index 659913b..c9de343 100644
--- a/example/rdp.go
+++ b/example/rdp.go
@@ -8,8 +8,6 @@ import (
 	"runtime"
 	"time"
 
-	"github.com/tomatome/grdp/plugin/cliprdr"
-
 	"github.com/tomatome/grdp/plugin"
 
 	"github.com/tomatome/grdp/core"
@@ -68,8 +66,14 @@ func uiRdp(info *Info) (error, *RdpClient) {
 		fmt.Println("Login:", err)
 		return err, nil
 	}
-	cc := cliprdr.NewCliprdrClient()
-	g.channels.Register(cc)
+	//cc := rail.NewClient()
+	//cc.DesktopHeight = uint16(info.Height)
+	//cc.DesktopWidth = uint16(info.Width)
+	//g.channels.Register(cc)
+	//cc1 := cliprdr.NewCliprdrClient()
+	//g.channels.Register(cc1)
+	//dvc := drdynvc.NewDvcClient()
+	//g.channels.Register(dvc)
 
 	g.pdu.On("error", func(e error) {
 		glog.Info("on error:", e)
@@ -81,25 +85,26 @@ func uiRdp(info *Info) (error, *RdpClient) {
 	}).On("ready", func() {
 		glog.Info("on ready")
 
-	}).On("update", func(rectangles []pdu.BitmapData) {
-		glog.Info("on update Bitmap:", len(rectangles))
+	}).On("bitmap", func(rectangles []pdu.BitmapData) {
+		glog.Info("Update Bitmap:", len(rectangles))
 		bs := make([]Bitmap, 0, 50)
 		for _, v := range rectangles {
 			IsCompress := v.IsCompress()
 			data := v.BitmapDataStream
-			//glog.Info("data:", data)
 			if IsCompress {
 				data = BitmapDecompress(&v)
 				IsCompress = false
 			}
 
-			//glog.Info(IsCompress, v.BitsPerPixel)
 			b := Bitmap{int(v.DestLeft), int(v.DestTop), int(v.DestRight), int(v.DestBottom),
 				int(v.Width), int(v.Height), Bpp(v.BitsPerPixel), IsCompress, data}
-			//glog.Infof("b:%+v, %d==%d", b.DestLeft, len(b.Data), b.Width*b.Height*4)
 			bs = append(bs, b)
 		}
 		ui_paint_bitmap(bs)
+	}).On("color", func(c *pdu.FastPathColorPdu) {
+		//b := Bitmap{int(c.X), int(c.Y), int(c.Width), int(c.Height),
+		//int(c.Width), int(c.Height), Bpp(24), false, c.Data}
+		//ui_paint_bitmap([]Bitmap{b})
 	})
 
 	return nil, g
@@ -112,7 +117,6 @@ func (g *RdpClient) Login() error {
 	if err != nil {
 		return fmt.Errorf("[dial err] %v", err)
 	}
-	//defer conn.Close()
 
 	g.tpkt = tpkt.New(core.NewSocketLayer(conn), nla.NewNTLMv2(domain, user, pwd))
 	g.x224 = x224.New(g.tpkt)
@@ -121,7 +125,11 @@ func (g *RdpClient) Login() error {
 	g.pdu = pdu.NewClient(g.sec)
 	g.channels = plugin.NewChannels(g.sec)
 
-	g.mcs.SetClientCoreData(uint16(g.Width), uint16(g.Height))
+	g.mcs.SetClientDesktop(uint16(g.Width), uint16(g.Height))
+	//g.mcs.SetClientCliprdr()
+	//g.mcs.SetClientDynvcProtocol()
+	//g.mcs.SetClientRemoteProgram()
+	//g.sec.SetAlternateShell("notepad")
 
 	g.sec.SetUser(user)
 	g.sec.SetPwd(pwd)
@@ -144,7 +152,7 @@ func (g *RdpClient) Login() error {
 }
 
 func (g *RdpClient) KeyUp(sc int, name string) {
-	glog.Debug("KeyUp:", sc, "name:", name)
+	glog.Debugf("KeyUp: 0x%x, name: %s", sc, name)
 
 	p := &pdu.ScancodeKeyEvent{}
 	p.KeyCode = uint16(sc)
@@ -152,7 +160,7 @@ func (g *RdpClient) KeyUp(sc int, name string) {
 	g.pdu.SendInputEvents(pdu.INPUT_EVENT_SCANCODE, []pdu.InputEventsInterface{p})
 }
 func (g *RdpClient) KeyDown(sc int, name string) {
-	glog.Debug("KeyDown:", sc, "name:", name)
+	glog.Debugf("KeyDown: 0x%x, name: %s", sc, name)
 
 	p := &pdu.ScancodeKeyEvent{}
 	p.KeyCode = uint16(sc)
diff --git a/example/ui.go b/example/ui.go
index 48cf300..ba1478b 100644
--- a/example/ui.go
+++ b/example/ui.go
@@ -77,10 +77,10 @@ func appMain(driver gxui.Driver) {
 	user.SetDesiredWidth(width / 4)
 	passwd.SetDesiredWidth(width / 4)
 	//ip.SetText("192.168.18.100:5902")
-	ip.SetText("192.168.18.207:3389")
-	//user.SetText("administrator")
-	user.SetText("wren")
-	passwd.SetText("wren")
+	ip.SetText("192.168.0.132:3389")
+	user.SetText("administrator")
+	passwd.SetText("Jhadmin123")
+	//passwd.SetText("wren")
 
 	bok := theme.CreateButton()
 	bok.SetText("OK")
diff --git a/glog/log.go b/glog/log.go
index e4a9c13..82021e8 100644
--- a/glog/log.go
+++ b/glog/log.go
@@ -6,10 +6,6 @@ import (
 	"sync"
 )
 
-func init() {
-
-}
-
 var (
 	logger *log.Logger
 	level  LEVEL
diff --git a/go.sum b/go.sum
index 129e936..8bc762c 100644
--- a/go.sum
+++ b/go.sum
@@ -36,8 +36,8 @@ github.com/shirou/w32 v0.0.0-20160930032740-bb4de0191aa4/go.mod h1:qsXQc7+bwAM3Q
 github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
 github.com/stretchr/testify v1.5.1 h1:nOGnQDM7FYENwehXlg/kFVnos3rEvtKTjRvOWSzb6H4=
 github.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=
-github.com/tomatome/win v0.3.0 h1:IezE/bpr7HBb5/gl4IRxputcFOrjGZHHiL3Rn1JswEo=
-github.com/tomatome/win v0.3.0/go.mod h1:YY2OpEdJ5Z1gOya7w+W7Ziv/lRIiokxlQgj4i7QgbhY=
+github.com/tomatome/win v0.3.1 h1:jDUqhWwWNVAyr/hwzMWfgSIDXX9I4Opjy/XAlPAKh/Q=
+github.com/tomatome/win v0.3.1/go.mod h1:YY2OpEdJ5Z1gOya7w+W7Ziv/lRIiokxlQgj4i7QgbhY=
 golang.org/x/crypto v0.0.0-20220622213112-05595931fe9d h1:sK3txAijHtOK88l68nt020reeT1ZdKLIYetKl95FzVY=
 golang.org/x/crypto v0.0.0-20220622213112-05595931fe9d/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
 golang.org/x/image v0.0.0-20220617043117-41969df76e82 h1:KpZB5pUSBvrHltNEdK/tw0xlPeD13M6M6aGP32gKqiw=
diff --git a/plugin/channel.go b/plugin/channel.go
index a00060c..b3e5ab2 100644
--- a/plugin/channel.go
+++ b/plugin/channel.go
@@ -171,10 +171,14 @@ const (
 	RDPDR_SVC_CHANNEL_NAME   = "rdpdr"   //设备重定向(打印机，磁盘，端口，智能卡等)
 	RDPSND_SVC_CHANNEL_NAME  = "rdpsnd"  //音频输出
 	RAIL_SVC_CHANNEL_NAME    = "rail"    //远程应用
-	ENCOMSP_SVC_CHANNEL_NAME = "encomsp" //多方虚拟通道
+	DRDYNVC_SVC_CHANNEL_NAME = "drdynvc" //动态虚拟通道
 	REMDESK_SVC_CHANNEL_NAME = "remdesk" //远程协助
 )
 
+const (
+	RDPGFX_DVC_CHANNEL_NAME = "Microsoft::Windows::RDS::Graphics" //图形扩展
+)
+
 var StaticVirtualChannels = map[string]int{
 	CLIPRDR_SVC_CHANNEL_NAME: CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_ENCRYPT_RDP |
 		CHANNEL_OPTION_COMPRESS_RDP | CHANNEL_OPTION_SHOW_PROTOCOL,
diff --git a/plugin/cliprdr/cliprdr.go b/plugin/cliprdr/cliprdr.go
index 963bd13..070b715 100644
--- a/plugin/cliprdr/cliprdr.go
+++ b/plugin/cliprdr/cliprdr.go
@@ -54,6 +54,12 @@ import (
  *
  */
 
+const (
+	ChannelName   = plugin.CLIPRDR_SVC_CHANNEL_NAME
+	ChannelOption = plugin.CHANNEL_OPTION_INITIALIZED | plugin.CHANNEL_OPTION_ENCRYPT_RDP |
+		plugin.CHANNEL_OPTION_COMPRESS_RDP | plugin.CHANNEL_OPTION_SHOW_PROTOCOL
+)
+
 type MsgType uint16
 
 const (
@@ -333,8 +339,7 @@ func (c *CliprdrClient) Sender(f core.ChannelSender) {
 	c.w = f
 }
 func (c *CliprdrClient) GetType() (string, uint32) {
-	return plugin.CLIPRDR_SVC_CHANNEL_NAME, plugin.CHANNEL_OPTION_INITIALIZED | plugin.CHANNEL_OPTION_ENCRYPT_RDP |
-		plugin.CHANNEL_OPTION_COMPRESS_RDP | plugin.CHANNEL_OPTION_SHOW_PROTOCOL
+	return ChannelName, ChannelOption
 }
 
 func (c *CliprdrClient) Process(s []byte) {
diff --git a/protocol/pdu/caps.go b/protocol/pdu/caps.go
index 72ac07e..9f21172 100644
--- a/protocol/pdu/caps.go
+++ b/protocol/pdu/caps.go
@@ -47,6 +47,69 @@ const (
 	CAPSSETTYPE_FRAME_ACKNOWLEDGE             = 0x001E
 )
 
+func (c CapsType) String() string {
+	switch c {
+	case CAPSTYPE_GENERAL:
+		return "CAPSTYPE_GENERAL"
+	case CAPSTYPE_BITMAP:
+		return "CAPSTYPE_BITMAP"
+	case CAPSTYPE_ORDER:
+		return "CAPSTYPE_ORDER"
+	case CAPSTYPE_BITMAPCACHE:
+		return "CAPSTYPE_BITMAPCACHE"
+	case CAPSTYPE_CONTROL:
+		return "CAPSTYPE_CONTROL"
+	case CAPSTYPE_ACTIVATION:
+		return "CAPSTYPE_ACTIVATION"
+	case CAPSTYPE_POINTER:
+		return "CAPSTYPE_POINTER"
+	case CAPSTYPE_SHARE:
+		return "CAPSTYPE_SHARE"
+	case CAPSTYPE_COLORCACHE:
+		return "CAPSTYPE_COLORCACHE"
+	case CAPSTYPE_SOUND:
+		return "CAPSTYPE_SOUND"
+	case CAPSTYPE_INPUT:
+		return "CAPSTYPE_INPUT"
+	case CAPSTYPE_FONT:
+		return "CAPSTYPE_FONT"
+	case CAPSTYPE_BRUSH:
+		return "CAPSTYPE_BRUSH"
+	case CAPSTYPE_GLYPHCACHE:
+		return "CAPSTYPE_GLYPHCACHE"
+	case CAPSTYPE_OFFSCREENCACHE:
+		return "CAPSTYPE_OFFSCREENCACHE"
+	case CAPSTYPE_BITMAPCACHE_HOSTSUPPORT:
+		return "CAPSTYPE_BITMAPCACHE_HOSTSUPPORT"
+	case CAPSTYPE_BITMAPCACHE_REV2:
+		return "CAPSTYPE_BITMAPCACHE_REV2"
+	case CAPSTYPE_VIRTUALCHANNEL:
+		return "CAPSTYPE_VIRTUALCHANNEL"
+	case CAPSTYPE_DRAWNINEGRIDCACHE:
+		return "CAPSTYPE_DRAWNINEGRIDCACHE"
+	case CAPSTYPE_DRAWGDIPLUS:
+		return "CAPSTYPE_DRAWGDIPLUS"
+	case CAPSTYPE_RAIL:
+		return "CAPSTYPE_RAIL"
+	case CAPSTYPE_WINDOW:
+		return "CAPSTYPE_WINDOW"
+	case CAPSETTYPE_COMPDESK:
+		return "CAPSETTYPE_COMPDESK"
+	case CAPSETTYPE_MULTIFRAGMENTUPDATE:
+		return "CAPSETTYPE_MULTIFRAGMENTUPDATE"
+	case CAPSETTYPE_LARGE_POINTER:
+		return "CAPSETTYPE_LARGE_POINTER"
+	case CAPSETTYPE_SURFACE_COMMANDS:
+		return "CAPSETTYPE_SURFACE_COMMANDS"
+	case CAPSETTYPE_BITMAP_CODECS:
+		return "CAPSETTYPE_BITMAP_CODECS"
+	case CAPSSETTYPE_FRAME_ACKNOWLEDGE:
+		return "CAPSSETTYPE_FRAME_ACKNOWLEDGE"
+	}
+
+	return "Unknown"
+}
+
 type MajorType uint16
 
 const (
@@ -119,7 +182,7 @@ const (
 	TS_NEG_FAST_GLYPH_INDEX               = 0x18
 	TS_NEG_ELLIPSE_SC_INDEX               = 0x19
 	TS_NEG_ELLIPSE_CB_INDEX               = 0x1A
-	TS_NEG_INDEX_INDEX                    = 0x1B
+	TS_NEG_GLYPH_INDEX_INDEX              = 0x1B
 )
 
 type OrderEx uint16
@@ -235,6 +298,14 @@ const (
 	KBDFLAGS_RELEASE  = 0x8000
 )
 
+type SurfaceCmdFlags uint32
+
+const (
+	SURFCMDS_SET_SURFACE_BITS    = 0x00000002
+	SURFCMDS_FRAME_MARKER        = 0x00000010
+	SURFCMDS_STREAM_SURFACE_BITS = 0x00000040
+)
+
 type Capability interface {
 	Type() CapsType
 }
@@ -328,7 +399,7 @@ type PointerCapability struct {
 	ColorPointerFlag      uint16 `struc:"little"`
 	ColorPointerCacheSize uint16 `struc:"little"`
 	// old version of rdp doesn't support ...
-	// PointerCacheSize uint16 `struc:"little"` // only server need
+	PointerCacheSize uint16 `struc:"little"` // only server need
 }
 
 func (*PointerCapability) Type() CapsType {
@@ -393,6 +464,22 @@ func (*OffscreenBitmapCacheCapability) Type() CapsType {
 	return CAPSTYPE_OFFSCREENCACHE
 }
 
+type BitmapCache2Capability struct {
+	BitmapCachePersist uint16   `struc:"little"`
+	Pad2octets         uint8    `struc:"little"`
+	CachesNum          uint8    `struc:"little"`
+	BmpC0Cells         uint32   `struc:"little"`
+	BmpC1Cells         uint32   `struc:"little"`
+	BmpC2Cells         uint32   `struc:"little"`
+	BmpC3Cells         uint32   `struc:"little"`
+	BmpC4Cells         uint32   `struc:"little"`
+	Pad2octets1        [12]byte `struc:"little"`
+}
+
+func (*BitmapCache2Capability) Type() CapsType {
+	return CAPSTYPE_BITMAPCACHE_REV2
+}
+
 type VirtualChannelCapability struct {
 	// 14000c000000000000000000
 	Flags       VirtualChannelCompressionFlag `struc:"little"`
@@ -568,6 +655,24 @@ func (*SurfaceCommandsCapability) Type() CapsType {
 	return CAPSETTYPE_SURFACE_COMMANDS
 }
 
+type FrameAcknowledgeCapability struct {
+	FrameCount uint32 `struc:"little"`
+}
+
+func (*FrameAcknowledgeCapability) Type() CapsType {
+	return CAPSSETTYPE_FRAME_ACKNOWLEDGE
+}
+
+type DrawNineGridCapability struct {
+	SupportLevel uint32 `struc:"little"`
+	CacheSize    uint16 `struc:"little"`
+	CacheEntries uint16 `struc:"little"`
+}
+
+func (*DrawNineGridCapability) Type() CapsType {
+	return CAPSTYPE_DRAWNINEGRIDCACHE
+}
+
 func readCapability(r io.Reader) (Capability, error) {
 	capType, err := core.ReadUint16LE(r)
 	if err != nil {
@@ -639,9 +744,8 @@ func readCapability(r io.Reader) (Capability, error) {
 		c = &DesktopCompositionCapability{}
 	case CAPSETTYPE_SURFACE_COMMANDS:
 		c = &SurfaceCommandsCapability{}
-	//case CAPSSETTYPE_FRAME_ACKNOWLEDGE:
-	//c =
-	//glog.Error("CAPSSETTYPE_FRAME_ACKNOWLEDGE")
+	case CAPSSETTYPE_FRAME_ACKNOWLEDGE:
+		c = &FrameAcknowledgeCapability{}
 	default:
 		err := errors.New(fmt.Sprintf("unsupported Capability type 0x%04x", capType))
 		glog.Error(err)
@@ -651,6 +755,6 @@ func readCapability(r io.Reader) (Capability, error) {
 		glog.Error("Capability unpack error", err, fmt.Sprintf("0x%04x", capType), hex.EncodeToString(capBytes))
 		return nil, err
 	}
-	glog.Debugf("Capability: %+v", c)
+	glog.Debugf("Capability<%s>: %+v", c.Type(), c)
 	return c, nil
 }
diff --git a/protocol/pdu/data.go b/protocol/pdu/data.go
index b1e0cef..68f3184 100644
--- a/protocol/pdu/data.go
+++ b/protocol/pdu/data.go
@@ -19,6 +19,8 @@ const (
 	PDUTYPE_SERVER_REDIR_PKT = 0x1A
 )
 
+type PduType2 uint8
+
 const (
 	PDUTYPE2_UPDATE                      = 0x02
 	PDUTYPE2_CONTROL                     = 0x14
@@ -46,6 +48,61 @@ const (
 	PDUTYPE2_MONITOR_LAYOUT_PDU          = 0x37
 )
 
+func (p PduType2) String() string {
+	switch p {
+	case PDUTYPE2_UPDATE:
+		return "PDUTYPE2_UPDATE"
+	case PDUTYPE2_CONTROL:
+		return "PDUTYPE2_CONTROL"
+	case PDUTYPE2_POINTER:
+		return "PDUTYPE2_POINTER"
+	case PDUTYPE2_INPUT:
+		return "PDUTYPE2_INPUT"
+	case PDUTYPE2_SYNCHRONIZE:
+		return "PDUTYPE2_SYNCHRONIZE"
+	case PDUTYPE2_REFRESH_RECT:
+		return "PDUTYPE2_REFRESH_RECT"
+	case PDUTYPE2_PLAY_SOUND:
+		return "PDUTYPE2_PLAY_SOUND"
+	case PDUTYPE2_SUPPRESS_OUTPUT:
+		return "PDUTYPE2_SUPPRESS_OUTPUT"
+	case PDUTYPE2_SHUTDOWN_REQUEST:
+		return "PDUTYPE2_SHUTDOWN_REQUEST"
+	case PDUTYPE2_SHUTDOWN_DENIED:
+		return "PDUTYPE2_SHUTDOWN_DENIED"
+	case PDUTYPE2_SAVE_SESSION_INFO:
+		return "PDUTYPE2_SAVE_SESSION_INFO"
+	case PDUTYPE2_FONTLIST:
+		return "PDUTYPE2_FONTLIST"
+	case PDUTYPE2_FONTMAP:
+		return "PDUTYPE2_FONTMAP"
+	case PDUTYPE2_SET_KEYBOARD_INDICATORS:
+		return "PDUTYPE2_SET_KEYBOARD_INDICATORS"
+	case PDUTYPE2_BITMAPCACHE_PERSISTENT_LIST:
+		return "PDUTYPE2_BITMAPCACHE_PERSISTENT_LIST"
+	case PDUTYPE2_BITMAPCACHE_ERROR_PDU:
+		return "PDUTYPE2_BITMAPCACHE_ERROR_PDU"
+	case PDUTYPE2_SET_KEYBOARD_IME_STATUS:
+		return "PDUTYPE2_SET_KEYBOARD_IME_STATUS"
+	case PDUTYPE2_OFFSCRCACHE_ERROR_PDU:
+		return "PDUTYPE2_OFFSCRCACHE_ERROR_PDU"
+	case PDUTYPE2_SET_ERROR_INFO_PDU:
+		return "PDUTYPE2_SET_ERROR_INFO_PDU"
+	case PDUTYPE2_DRAWNINEGRID_ERROR_PDU:
+		return "PDUTYPE2_DRAWNINEGRID_ERROR_PDU"
+	case PDUTYPE2_DRAWGDIPLUS_ERROR_PDU:
+		return "PDUTYPE2_DRAWGDIPLUS_ERROR_PDU"
+	case PDUTYPE2_ARC_STATUS_PDU:
+		return "PDUTYPE2_ARC_STATUS_PDU"
+	case PDUTYPE2_STATUS_INFO_PDU:
+		return "PDUTYPE2_STATUS_INFO_PDU"
+	case PDUTYPE2_MONITOR_LAYOUT_PDU:
+		return "PDUTYPE2_MONITOR_LAYOUT_PDU"
+	}
+
+	return "Unknown"
+}
+
 const (
 	CTRLACTION_REQUEST_CONTROL = 0x0001
 	CTRLACTION_GRANTED_CONTROL = 0x0002
@@ -60,25 +117,68 @@ const (
 	STREAM_HI        = 0x04
 )
 
+type FastPathUpdateType uint8
+
 const (
-	FASTPATH_UPDATETYPE_ORDERS       = 0x0
-	FASTPATH_UPDATETYPE_BITMAP       = 0x1
-	FASTPATH_UPDATETYPE_PALETTE      = 0x2
-	FASTPATH_UPDATETYPE_SYNCHRONIZE  = 0x3
-	FASTPATH_UPDATETYPE_SURFCMDS     = 0x4
-	FASTPATH_UPDATETYPE_PTR_NULL     = 0x5
-	FASTPATH_UPDATETYPE_PTR_DEFAULT  = 0x6
-	FASTPATH_UPDATETYPE_PTR_POSITION = 0x8
-	FASTPATH_UPDATETYPE_COLOR        = 0x9
-	FASTPATH_UPDATETYPE_CACHED       = 0xA
-	FASTPATH_UPDATETYPE_POINTER      = 0xB
+	FASTPATH_UPDATETYPE_ORDERS        = 0x0
+	FASTPATH_UPDATETYPE_BITMAP        = 0x1
+	FASTPATH_UPDATETYPE_PALETTE       = 0x2
+	FASTPATH_UPDATETYPE_SYNCHRONIZE   = 0x3
+	FASTPATH_UPDATETYPE_SURFCMDS      = 0x4
+	FASTPATH_UPDATETYPE_PTR_NULL      = 0x5
+	FASTPATH_UPDATETYPE_PTR_DEFAULT   = 0x6
+	FASTPATH_UPDATETYPE_PTR_POSITION  = 0x8
+	FASTPATH_UPDATETYPE_COLOR         = 0x9
+	FASTPATH_UPDATETYPE_CACHED        = 0xA
+	FASTPATH_UPDATETYPE_POINTER       = 0xB
+	FASTPATH_UPDATETYPE_LARGE_POINTER = 0xC
 )
 
+func (t FastPathUpdateType) String() string {
+	switch t {
+	case FASTPATH_UPDATETYPE_ORDERS:
+		return "FASTPATH_UPDATETYPE_ORDERS"
+	case FASTPATH_UPDATETYPE_BITMAP:
+		return "FASTPATH_UPDATETYPE_BITMAP"
+	case FASTPATH_UPDATETYPE_PALETTE:
+		return "FASTPATH_UPDATETYPE_PALETTE"
+	case FASTPATH_UPDATETYPE_SYNCHRONIZE:
+		return "FASTPATH_UPDATETYPE_SYNCHRONIZE"
+	case FASTPATH_UPDATETYPE_SURFCMDS:
+		return "FASTPATH_UPDATETYPE_SURFCMDS"
+	case FASTPATH_UPDATETYPE_PTR_NULL:
+		return "FASTPATH_UPDATETYPE_PTR_NULL"
+	case FASTPATH_UPDATETYPE_PTR_DEFAULT:
+		return "FASTPATH_UPDATETYPE_PTR_DEFAULT"
+	case FASTPATH_UPDATETYPE_PTR_POSITION:
+		return "FASTPATH_UPDATETYPE_PTR_POSITION"
+	case FASTPATH_UPDATETYPE_COLOR:
+		return "FASTPATH_UPDATETYPE_COLOR"
+	case FASTPATH_UPDATETYPE_CACHED:
+		return "FASTPATH_UPDATETYPE_CACHED"
+	case FASTPATH_UPDATETYPE_POINTER:
+		return "FASTPATH_UPDATETYPE_POINTER"
+	case FASTPATH_UPDATETYPE_LARGE_POINTER:
+		return "FASTPATH_UPDATETYPE_LARGE_POINTER"
+	}
+
+	return "Unknown"
+}
+
 const (
 	BITMAP_COMPRESSION = 0x0001
 	//NO_BITMAP_COMPRESSION_HDR = 0x0400
 )
 
+/* compression types */
+const (
+	RDP_MPPC_BIG        = 0x01
+	RDP_MPPC_COMPRESSED = 0x20
+	RDP_MPPC_RESET      = 0x40
+	RDP_MPPC_FLUSH      = 0x80
+	RDP_MPPC_DICT_SIZE  = 65536
+)
+
 type ShareDataHeader struct {
 	SharedId           uint32 `struc:"little"`
 	Padding1           uint8  `struc:"little"`
@@ -154,7 +254,7 @@ func readDemandActivePDU(r io.Reader) (*DemandActivePDU, error) {
 	d.SourceDescriptor = sourceDescriptorBytes
 	d.NumberCapabilities, err = core.ReadUint16LE(r)
 	d.Pad2Octets, err = core.ReadUint16LE(r)
-	d.CapabilitySets = make([]Capability, 0)
+	d.CapabilitySets = make([]Capability, 0, d.NumberCapabilities)
 	glog.Debug("NumberCapabilities is", d.NumberCapabilities)
 	for i := 0; i < int(d.NumberCapabilities); i++ {
 		c, err := readCapability(r)
@@ -166,7 +266,6 @@ func readDemandActivePDU(r io.Reader) (*DemandActivePDU, error) {
 	}
 	d.NumberCapabilities = uint16(len(d.CapabilitySets))
 	d.SessionId, err = core.ReadUInt32LE(r)
-	//glog.Info("SessionId:", d.SessionId)
 	if err != nil {
 		return nil, err
 	}
@@ -199,9 +298,6 @@ func (c *ConfirmActivePDU) Serialize() []byte {
 		core.WriteUInt16LE(uint16(capa.Type()), capsBuff)
 		capBuff := &bytes.Buffer{}
 		struc.Pack(capBuff, capa)
-		if capa.Type() == CAPSTYPE_INPUT {
-			core.WriteBytes([]byte{0x0c, 0x00, 0x00, 0x00}, capBuff)
-		}
 		capBytes := capBuff.Bytes()
 		core.WriteUInt16LE(uint16(len(capBytes)+4), capsBuff)
 		core.WriteBytes(capBytes, capsBuff)
@@ -209,8 +305,8 @@ func (c *ConfirmActivePDU) Serialize() []byte {
 	capsBytes := capsBuff.Bytes()
 
 	core.WriteUInt16LE(uint16(2+2+len(capsBytes)), buff)
-	core.WriteBytes([]byte(c.SourceDescriptor), buff)
-	core.WriteUInt16LE(uint16(len(c.CapabilitySets)), buff)
+	core.WriteBytes(c.SourceDescriptor, buff)
+	core.WriteUInt16LE(c.NumberCapabilities, buff)
 	core.WriteUInt16LE(c.Pad2Octets, buff)
 	core.WriteBytes(capsBytes, buff)
 	return buff.Bytes()
@@ -335,7 +431,7 @@ func readDataPDU(r io.Reader) (*DataPDU, error) {
 		return nil, err
 	}
 	var d DataPDUData
-	glog.Debugf("header=%02x", header.PDUType2)
+	glog.Debugf("PDUType2 0x%02x", header.PDUType2)
 	switch header.PDUType2 {
 	case PDUTYPE2_SYNCHRONIZE:
 		d = &SynchronizeDataPDU{}
@@ -365,7 +461,7 @@ func readDataPDU(r io.Reader) (*DataPDU, error) {
 		}
 	}
 
-	glog.Debugf("d=%+v", d)
+	glog.Debugf("PDUType2<%s>: %+v", PduType2(d.Type2()), d)
 	p := &DataPDU{
 		Header: header,
 		Data:   d,
@@ -499,7 +595,7 @@ func (s *SaveSessionInfo) logonPlainNotify(r io.Reader) (err error) {
 func (s *SaveSessionInfo) logonInfoExtended(r io.Reader) (err error) {
 	s.Length, err = core.ReadUint16LE(r)
 	s.FieldsPresent, err = core.ReadUInt32LE(r)
-	glog.Info("FieldsPresent:", s.FieldsPresent)
+	//glog.Info("FieldsPresent:", s.FieldsPresent)
 	// auto reconnect cookie
 	if s.FieldsPresent&LOGON_EX_AUTORECONNECTCOOKIE != 0 {
 		core.ReadUInt32LE(r)
@@ -638,8 +734,43 @@ func (*FastPathBitmapUpdateDataPDU) FastPathUpdateType() uint8 {
 	return FASTPATH_UPDATETYPE_BITMAP
 }
 
+type FastPathColorPdu struct {
+	CacheIdx uint16
+	X        uint16
+	Y        uint16
+	Width    uint16
+	Height   uint16
+	MaskLen  uint16 `struc:"little,sizeof=Mask"`
+	DataLen  uint16 `struc:"little,sizeof=Data"`
+	Mask     []byte
+	Data     []byte
+}
+
+func (*FastPathColorPdu) FastPathUpdateType() uint8 {
+	return FASTPATH_UPDATETYPE_COLOR
+}
+func (f *FastPathColorPdu) Unpack(r io.Reader) error {
+	return struc.Unpack(r, f)
+}
+
+type FastPathSurfaceCmds struct {
+}
+
+func (*FastPathSurfaceCmds) FastPathUpdateType() uint8 {
+	return FASTPATH_UPDATETYPE_SURFCMDS
+}
+func (f *FastPathSurfaceCmds) Unpack(r io.Reader) error {
+	cmdType, _ := core.ReadUint16LE(r)
+	switch cmdType {
+
+	}
+
+	return nil
+}
+
 type FastPathUpdatePDU struct {
 	UpdateHeader     uint8
+	Fragmentation    uint8
 	CompressionFlags uint8
 	Size             uint16
 	Data             UpdateData
@@ -649,47 +780,47 @@ const (
 	FASTPATH_OUTPUT_COMPRESSION_USED = 0x2
 )
 
-func readFastPathUpdatePDU(r io.Reader) (*FastPathUpdatePDU, error) {
+const (
+	FASTPATH_FRAGMENT_SINGLE = (0x0 << 4)
+	FASTPATH_FRAGMENT_LAST   = (0x1 << 4)
+	FASTPATH_FRAGMENT_FIRST  = (0x2 << 4)
+	FASTPATH_FRAGMENT_NEXT   = (0x3 << 4)
+)
+
+func readFastPathUpdatePDU(r io.Reader, code uint8) (*FastPathUpdatePDU, error) {
 	f := &FastPathUpdatePDU{}
 	var err error
-	f.UpdateHeader, err = core.ReadUInt8(r)
-	if err != nil {
-		return nil, err
-	}
-	if (f.UpdateHeader>>4)&FASTPATH_OUTPUT_COMPRESSION_USED != 0 {
-		f.CompressionFlags, err = core.ReadUInt8(r)
-	}
-
-	f.Size, err = core.ReadUint16LE(r)
-	if err != nil {
-		return nil, err
-	}
-	if f.Size == 0 {
-		return f, nil
-	}
-	dataBytes, err := core.ReadBytes(int(f.Size), r)
-	if err != nil {
-		glog.Info(err)
-		return nil, err
-	}
-
 	var d UpdateData
-	glog.Debugf("Fast Path PDU type 0x%x", f.UpdateHeader)
-	switch f.UpdateHeader & 0xf {
+	//glog.Debugf("FastPathPDU type %s(0x%x)", FastPathUpdateType(code), code)
+	switch code {
+	case FASTPATH_UPDATETYPE_ORDERS:
+		d = &FastPathOrdersPDU{}
 	case FASTPATH_UPDATETYPE_BITMAP:
 		d = &FastPathBitmapUpdateDataPDU{}
-
+	case FASTPATH_UPDATETYPE_PALETTE:
+	case FASTPATH_UPDATETYPE_SYNCHRONIZE:
+	case FASTPATH_UPDATETYPE_SURFCMDS:
+		//d = &FastPathSurfaceCmds{}
+	case FASTPATH_UPDATETYPE_PTR_NULL:
+	case FASTPATH_UPDATETYPE_PTR_DEFAULT:
+	case FASTPATH_UPDATETYPE_PTR_POSITION:
+	case FASTPATH_UPDATETYPE_COLOR:
+		//d = &FastPathColorPdu{}
+	case FASTPATH_UPDATETYPE_CACHED:
+	case FASTPATH_UPDATETYPE_POINTER:
+	case FASTPATH_UPDATETYPE_LARGE_POINTER:
 	default:
-		glog.Debugf("Unknown Fast Path PDU type 0x%x", f.UpdateHeader)
-		return f, errors.New(fmt.Sprintf("Unknown Fast Path PDU type 0x%x", f.UpdateHeader))
-		//d = nil
+		glog.Debugf("Unknown FastPathPDU type 0x%x", code)
+		return f, errors.New(fmt.Sprintf("Unknown FastPathPDU type 0x%x", code))
 	}
 	if d != nil {
-		err = d.Unpack(bytes.NewReader(dataBytes))
+		err = d.Unpack(r)
 		if err != nil {
-			glog.Error("Unpack:", err)
+			//glog.Error("Unpack:", err)
 			return nil, err
 		}
+	} else {
+		return nil, errors.New(fmt.Sprintf("Unsupport FastPathPDU type 0x%x", code))
 	}
 
 	f.Data = d
diff --git a/protocol/pdu/pdu.go b/protocol/pdu/pdu.go
index 00ba8de..c929f47 100644
--- a/protocol/pdu/pdu.go
+++ b/protocol/pdu/pdu.go
@@ -69,16 +69,30 @@ func NewPDULayer(t core.Transport) *PDULayer {
 				MaximumOrderLevel:       1,
 				OrderFlags:              NEGOTIATEORDERSUPPORT,
 				DesktopSaveSize:         480 * 480,
+				TextANSICodePage:        0x4e4,
 			},
-			CAPSTYPE_BITMAPCACHE:           &BitmapCacheCapability{},
-			CAPSTYPE_POINTER:               &PointerCapability{ColorPointerCacheSize: 20},
-			CAPSTYPE_INPUT:                 &InputCapability{},
-			CAPSTYPE_BRUSH:                 &BrushCapability{},
-			CAPSTYPE_GLYPHCACHE:            &GlyphCapability{},
-			CAPSTYPE_OFFSCREENCACHE:        &OffscreenBitmapCacheCapability{},
-			CAPSTYPE_VIRTUALCHANNEL:        &VirtualChannelCapability{},
-			CAPSTYPE_SOUND:                 &SoundCapability{},
-			CAPSETTYPE_MULTIFRAGMENTUPDATE: &MultiFragmentUpdate{},
+			CAPSTYPE_CONTROL:         &ControlCapability{0, 0, 2, 2},
+			CAPSTYPE_ACTIVATION:      &WindowActivationCapability{},
+			CAPSTYPE_POINTER:         &PointerCapability{1, 20, 20},
+			CAPSTYPE_SHARE:           &ShareCapability{},
+			CAPSTYPE_COLORCACHE:      &ColorCacheCapability{6, 0},
+			CAPSTYPE_SOUND:           &SoundCapability{0x0001, 0},
+			CAPSTYPE_INPUT:           &InputCapability{},
+			CAPSTYPE_FONT:            &FontCapability{0x0001, 0},
+			CAPSTYPE_BRUSH:           &BrushCapability{BRUSH_COLOR_8x8},
+			CAPSTYPE_GLYPHCACHE:      &GlyphCapability{},
+			CAPSETTYPE_BITMAP_CODECS: &BitmapCodecsCapability{},
+			CAPSTYPE_BITMAPCACHE_REV2: &BitmapCache2Capability{
+				BitmapCachePersist: 2,
+				CachesNum:          5,
+				BmpC0Cells:         0x258,
+				BmpC1Cells:         0x258,
+				BmpC2Cells:         0x800,
+				BmpC3Cells:         0x1000,
+				BmpC4Cells:         0x800,
+			},
+			CAPSTYPE_VIRTUALCHANNEL:        &VirtualChannelCapability{0, 1600},
+			CAPSETTYPE_MULTIFRAGMENTUPDATE: &MultiFragmentUpdate{65535},
 			CAPSTYPE_RAIL: &RemoteProgramsCapability{
 				RailSupportLevel: RAIL_LEVEL_SUPPORTED |
 					RAIL_LEVEL_SHELL_INTEGRATION_SUPPORTED |
@@ -89,6 +103,11 @@ func NewPDULayer(t core.Transport) *PDULayer {
 					RAIL_LEVEL_HANDSHAKE_EX_SUPPORTED |
 					RAIL_LEVEL_DOCKED_LANGBAR_SUPPORTED,
 			},
+			CAPSETTYPE_LARGE_POINTER: &LargePointerCapability{1},
+			CAPSETTYPE_SURFACE_COMMANDS: &SurfaceCommandsCapability{
+				CmdFlags: SURFCMDS_SET_SURFACE_BITS | SURFCMDS_STREAM_SURFACE_BITS | SURFCMDS_FRAME_MARKER,
+			},
+			CAPSSETTYPE_FRAME_ACKNOWLEDGE: &FrameAcknowledgeCapability{2},
 		},
 	}
 
@@ -117,11 +136,13 @@ func (p *PDULayer) SetFastPathSender(f core.FastPathSender) {
 type Client struct {
 	*PDULayer
 	clientCoreData *gcc.ClientCoreData
+	buff           *bytes.Buffer
 }
 
 func NewClient(t core.Transport) *Client {
 	c := &Client{
 		PDULayer: NewPDULayer(t),
+		buff:     &bytes.Buffer{},
 	}
 	c.transport.Once("connect", c.connect)
 	return c
@@ -136,7 +157,7 @@ func (c *Client) connect(data *gcc.ClientCoreData, userId uint16, channelId uint
 }
 
 func (c *Client) recvDemandActivePDU(s []byte) {
-	glog.Debug("PDU recvDemandActivePDU", hex.EncodeToString(s))
+	glog.Trace("PDU recvDemandActivePDU", hex.EncodeToString(s))
 	r := bytes.NewReader(s)
 	pdu, err := readPDU(r)
 	if err != nil {
@@ -151,6 +172,7 @@ func (c *Client) recvDemandActivePDU(s []byte) {
 	c.sharedId = pdu.Message.(*DemandActivePDU).SharedId
 	c.demandActivePDU = pdu.Message.(*DemandActivePDU)
 	for _, caps := range pdu.Message.(*DemandActivePDU).CapabilitySets {
+		glog.Debugf("serverCapabilities<%s>: %+v", caps.Type(), caps)
 		c.serverCapabilities[caps.Type()] = caps
 	}
 
@@ -163,21 +185,40 @@ func (c *Client) sendConfirmActivePDU() {
 	glog.Debug("PDU start sendConfirmActivePDU")
 
 	pdu := NewConfirmActivePDU()
-
 	generalCapa := c.clientCapabilities[CAPSTYPE_GENERAL].(*GeneralCapability)
 	generalCapa.OSMajorType = OSMAJORTYPE_WINDOWS
 	generalCapa.OSMinorType = OSMINORTYPE_WINDOWS_NT
-	generalCapa.ExtraFlags = LONG_CREDENTIALS_SUPPORTED | NO_BITMAP_COMPRESSION_HDR | ENC_SALTED_CHECKSUM
-	//if not self._fastPathSender is None:
-	generalCapa.ExtraFlags |= FASTPATH_OUTPUT_SUPPORTED
+	generalCapa.ExtraFlags = LONG_CREDENTIALS_SUPPORTED | NO_BITMAP_COMPRESSION_HDR |
+		FASTPATH_OUTPUT_SUPPORTED | AUTORECONNECT_SUPPORTED
+	generalCapa.RefreshRectSupport = 0
+	generalCapa.SuppressOutputSupport = 0
 
 	bitmapCapa := c.clientCapabilities[CAPSTYPE_BITMAP].(*BitmapCapability)
 	bitmapCapa.PreferredBitsPerPixel = c.clientCoreData.HighColorDepth
 	bitmapCapa.DesktopWidth = c.clientCoreData.DesktopWidth
 	bitmapCapa.DesktopHeight = c.clientCoreData.DesktopHeight
+	bitmapCapa.DesktopResizeFlag = 0x0001
 
 	orderCapa := c.clientCapabilities[CAPSTYPE_ORDER].(*OrderCapability)
-	orderCapa.OrderFlags |= ZEROBOUNDSDELTASSUPPORT
+	orderCapa.OrderFlags = NEGOTIATEORDERSUPPORT | ZEROBOUNDSDELTASSUPPORT |
+		COLORINDEXSUPPORT | ORDERFLAGS_EXTRA_FLAGS
+	orderCapa.OrderSupportExFlags |= ORDERFLAGS_EX_ALTSEC_FRAME_MARKER_SUPPORT
+	orderCapa.OrderSupport[TS_NEG_DSTBLT_INDEX] = 1
+	orderCapa.OrderSupport[TS_NEG_PATBLT_INDEX] = 1
+	orderCapa.OrderSupport[TS_NEG_SCRBLT_INDEX] = 1
+	/*orderCapa.OrderSupport[TS_NEG_LINETO_INDEX] = 1
+	orderCapa.OrderSupport[TS_NEG_MULTIOPAQUERECT_INDEX] = 1
+	orderCapa.OrderSupport[TS_NEG_POLYLINE_INDEX] = 1
+	orderCapa.OrderSupport[TS_NEG_GLYPH_INDEX_INDEX] = 1
+	orderCapa.OrderSupport[TS_NEG_MEMBLT_INDEX] = 1
+	orderCapa.OrderSupport[TS_NEG_MEM3BLT_INDEX] = 1
+	//orderCapa.OrderSupport[TS_NEG_DRAWNINEGRID_INDEX] = 1
+	orderCapa.OrderSupport[TS_NEG_SAVEBITMAP_INDEX] = 1
+	orderCapa.OrderSupport[TS_NEG_POLYGON_SC_INDEX] = 1
+	orderCapa.OrderSupport[TS_NEG_POLYGON_CB_INDEX] = 1
+	orderCapa.OrderSupport[TS_NEG_ELLIPSE_SC_INDEX] = 1
+	orderCapa.OrderSupport[TS_NEG_ELLIPSE_CB_INDEX] = 1*/
+	orderCapa.OrderSupport[TS_NEG_FAST_GLYPH_INDEX] = 1
 
 	inputCapa := c.clientCapabilities[CAPSTYPE_INPUT].(*InputCapability)
 	inputCapa.Flags = INPUT_FLAG_SCANCODES | INPUT_FLAG_MOUSEX | INPUT_FLAG_UNICODE
@@ -187,13 +228,26 @@ func (c *Client) sendConfirmActivePDU() {
 	inputCapa.KeyboardFunctionKey = c.clientCoreData.KeyboardFnKeys
 	inputCapa.ImeFileName = c.clientCoreData.ImeFileName
 
+	glyphCapa := c.clientCapabilities[CAPSTYPE_GLYPHCACHE].(*GlyphCapability)
+	/*glyphCapa.GlyphCache[0] = cacheEntry{254, 4}
+	glyphCapa.GlyphCache[1] = cacheEntry{254, 4}
+	glyphCapa.GlyphCache[2] = cacheEntry{254, 8}
+	glyphCapa.GlyphCache[3] = cacheEntry{254, 8}
+	glyphCapa.GlyphCache[4] = cacheEntry{254, 16}
+	glyphCapa.GlyphCache[5] = cacheEntry{254, 32}
+	glyphCapa.GlyphCache[6] = cacheEntry{254, 64}
+	glyphCapa.GlyphCache[7] = cacheEntry{254, 128}
+	glyphCapa.GlyphCache[8] = cacheEntry{254, 256}
+	glyphCapa.GlyphCache[9] = cacheEntry{64, 2048}
+	glyphCapa.FragCache = 0x01000100*/
+	glyphCapa.SupportLevel = GLYPH_SUPPORT_NONE
+
 	pdu.SharedId = c.sharedId
-	pdu.NumberCapabilities = c.demandActivePDU.NumberCapabilities
 	for _, v := range c.clientCapabilities {
-		glog.Debugf("clientCapabilities: 0x%04x", v.Type())
+		glog.Debugf("clientCapabilities<%s>: %+v", v.Type(), v)
 		pdu.CapabilitySets = append(pdu.CapabilitySets, v)
 	}
-
+	pdu.NumberCapabilities = uint16(len(pdu.CapabilitySets))
 	pdu.LengthSourceDescriptor = c.demandActivePDU.LengthSourceDescriptor
 	pdu.SourceDescriptor = c.demandActivePDU.SourceDescriptor
 	pdu.LengthCombinedCapabilities = c.demandActivePDU.LengthCombinedCapabilities
@@ -306,7 +360,7 @@ func (c *Client) recvServerFontMapPDU(s []byte) {
 }
 
 func (c *Client) recvPDU(s []byte) {
-	glog.Debug("PDU recvPDU", hex.EncodeToString(s))
+	glog.Trace("PDU recvPDU", hex.EncodeToString(s))
 	r := bytes.NewReader(s)
 	if r.Len() > 0 {
 		p, err := readPDU(r)
@@ -322,17 +376,56 @@ func (c *Client) recvPDU(s []byte) {
 
 func (c *Client) RecvFastPath(secFlag byte, s []byte) {
 	//glog.Debug("PDU RecvFastPath", hex.EncodeToString(s))
-	glog.Debug("PDU RecvFastPath", secFlag&0x2 != 0)
 	r := bytes.NewReader(s)
 	for r.Len() > 0 {
-		p, err := readFastPathUpdatePDU(r)
+		updateHeader, err := core.ReadUInt8(r)
+		if err != nil {
+			return
+		}
+		updateCode := updateHeader & 0x0f
+		fragmentation := updateHeader & 0x30
+		compression := updateHeader & 0xC0
+
+		var compressionFlags uint8 = 0
+		if compression == FASTPATH_OUTPUT_COMPRESSION_USED {
+			compressionFlags, err = core.ReadUInt8(r)
+		}
+
+		size, err := core.ReadUint16LE(r)
 		if err != nil {
+			return
+		}
+
+		glog.Debug("Code:", FastPathUpdateType(updateCode),
+			"compressionFlags:", compressionFlags,
+			"fragmentation:", fragmentation,
+			"size:", size, "len:", r.Len())
+		if compressionFlags&RDP_MPPC_COMPRESSED != 0 {
+			glog.Info("RDP_MPPC_COMPRESSED")
+		}
+		if fragmentation != FASTPATH_FRAGMENT_SINGLE {
+			if fragmentation == FASTPATH_FRAGMENT_FIRST {
+				c.buff.Reset()
+			}
+			b, _ := core.ReadBytes(r.Len(), r)
+			c.buff.Write(b)
+			if fragmentation != FASTPATH_FRAGMENT_LAST {
+				return
+			}
+			r = bytes.NewReader(c.buff.Bytes())
+		}
+		//glog.Info("len:", r.Len())
+		p, err := readFastPathUpdatePDU(r, updateCode)
+		if err != nil || p == nil || p.Data == nil {
 			glog.Debug("readFastPathUpdatePDU:", err)
-			//continue
 			return
 		}
-		if p.UpdateHeader == FASTPATH_UPDATETYPE_BITMAP {
-			c.Emit("update", p.Data.(*FastPathBitmapUpdateDataPDU).Rectangles)
+		if updateCode == FASTPATH_UPDATETYPE_BITMAP {
+			c.Emit("bitmap", p.Data.(*FastPathBitmapUpdateDataPDU).Rectangles)
+		} else if updateCode == FASTPATH_UPDATETYPE_COLOR {
+			c.Emit("color", p.Data.(*FastPathColorPdu))
+		} else if updateCode == FASTPATH_UPDATETYPE_ORDERS {
+			c.Emit("orders", p.Data.(*FastPathOrdersPDU).OrderPdus)
 		}
 	}
 }
diff --git a/protocol/rfb/rfb.go b/protocol/rfb/rfb.go
index 8be378b..3557351 100644
--- a/protocol/rfb/rfb.go
+++ b/protocol/rfb/rfb.go
@@ -5,6 +5,7 @@ import (
 	"bytes"
 	"crypto/des"
 	"encoding/hex"
+	"errors"
 	"fmt"
 	"io"
 	"log"
@@ -400,11 +401,17 @@ type RFB struct {
 func NewRFB(t core.Transport) *RFB {
 	fb := &RFB{t, RFB003008, SEC_INVALID, "", NewPixelFormat(), 0, &Rectangle{}, ""}
 
-	fb.Once("data", fb.recvProtocolVersion)
-
 	return fb
 }
 
+func (fb *RFB) Connect() error {
+	if fb.Transport == nil {
+		return errors.New("no transport")
+	}
+	fb.Once("data", fb.recvProtocolVersion)
+	return nil
+}
+
 func (fb *RFB) recvProtocolVersion(version string) {
 	if version != RFB003003 || version != RFB003007 || version != RFB003008 {
 		version = RFB003008
diff --git a/protocol/sec/sec.go b/protocol/sec/sec.go
index 555e5da..573e1a8 100644
--- a/protocol/sec/sec.go
+++ b/protocol/sec/sec.go
@@ -170,8 +170,9 @@ type RDPInfo struct {
 
 func NewRDPInfo() *RDPInfo {
 	info := &RDPInfo{
-		//Flag: INFO_MOUSE | INFO_UNICODE | INFO_LOGONNOTIFY | INFO_LOGONERRORS | INFO_DISABLECTRLALTDEL | INFO_ENABLEWINDOWSKEY | INFO_FORCE_ENCRYPTED_CS_PDU,
-		Flag:           INFO_MOUSE | INFO_UNICODE | INFO_LOGONNOTIFY | INFO_LOGONERRORS | INFO_DISABLECTRLALTDEL | INFO_ENABLEWINDOWSKEY | INFO_AUTOLOGON,
+		Flag: INFO_MOUSE | INFO_UNICODE | INFO_LOGONNOTIFY |
+			INFO_LOGONERRORS | INFO_DISABLECTRLALTDEL | INFO_ENABLEWINDOWSKEY |
+			INFO_FORCE_ENCRYPTED_CS_PDU | INFO_AUTOLOGON,
 		Domain:         []byte{0, 0},
 		UserName:       []byte{0, 0},
 		Password:       []byte{0, 0},
@@ -278,7 +279,7 @@ func (s *SEC) Write(b []byte) (n int, err error) {
 	if !s.enableEncryption {
 		return s.transport.Write(b)
 	}
-
+	glog.Info("b:", hex.EncodeToString(b))
 	data := s.encrytData(b)
 	return s.transport.Write(data)
 }
@@ -288,7 +289,7 @@ func (s *SEC) Close() error {
 }
 
 func (s *SEC) sendFlagged(flag uint16, data []byte) (n int, err error) {
-	glog.Debug("sendFlagged:", hex.EncodeToString(data))
+	glog.Trace("sendFlagged:", hex.EncodeToString(data))
 	b := s.encryt(flag, data)
 	return s.transport.Write(b)
 }
@@ -438,6 +439,7 @@ func (c *Client) SetAlternateShell(shell string) {
 	}
 	core.WriteUInt16LE(0, buff)
 	c.info.AlternateShell = buff.Bytes()
+	c.info.Flag |= INFO_RAIL
 }
 
 func (c *Client) SetUser(user string) {
@@ -476,10 +478,10 @@ func (c *Client) connect(clientData []interface{}, serverData []interface{}, use
 	c.serverData = serverData
 	c.userId = userId
 	for _, channel := range channels {
-		glog.Debug("channel:", channel.Name, channel.ID)
+		glog.Infof("channel: %s <%d>:", channel.Name, channel.ID)
 		if channel.Name == t125.GLOBAL_CHANNEL_NAME {
 			c.channelId = channel.ID
-			break
+			//break
 		}
 	}
 	c.enableEncryption = c.ClientCoreData().ServerSelectedProtocol == 0
@@ -853,8 +855,8 @@ func (c *Client) sendClientChallengeResponse(data []byte) {
 }
 
 func (c *Client) recvData(channel string, s []byte) {
-	glog.Debug("sec recvData", hex.EncodeToString(s))
-	glog.Debug(channel, len(s), ":", s)
+	glog.Trace("sec recvData", hex.EncodeToString(s))
+	glog.Debugf("channel<%s> data len: %d", channel, len(s))
 	data := c.decrytData(s)
 	if channel != t125.GLOBAL_CHANNEL_NAME {
 		c.Emit("channel", channel, data)
diff --git a/protocol/t125/gcc/gcc.go b/protocol/t125/gcc/gcc.go
index 9ad43a1..7f40956 100644
--- a/protocol/t125/gcc/gcc.go
+++ b/protocol/t125/gcc/gcc.go
@@ -6,8 +6,6 @@ import (
 	"io"
 	"os"
 
-	"github.com/tomatome/grdp/plugin"
-
 	"github.com/tomatome/grdp/glog"
 
 	"github.com/lunixbochs/struc"
@@ -276,11 +274,9 @@ type ClientNetworkData struct {
 }
 
 func NewClientNetworkData() *ClientNetworkData {
-	n := &ClientNetworkData{}
-	n.ChannelCount = 3
-	n.ChannelDefArray = make([]ChannelDef, 0, n.ChannelCount)
+	n := &ClientNetworkData{ChannelDefArray: make([]ChannelDef, 0, 100)}
 
-	var d1 ChannelDef
+	/*var d1 ChannelDef
 	d1.Name = plugin.RDPDR_SVC_CHANNEL_NAME
 	d1.Options = uint32(CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_ENCRYPT_RDP |
 		CHANNEL_OPTION_COMPRESS_RDP)
@@ -290,24 +286,27 @@ func NewClientNetworkData() *ClientNetworkData {
 	d2.Name = plugin.RDPSND_SVC_CHANNEL_NAME
 	d2.Options = uint32(CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_ENCRYPT_RDP |
 		CHANNEL_OPTION_COMPRESS_RDP | CHANNEL_OPTION_SHOW_PROTOCOL)
-	n.ChannelDefArray = append(n.ChannelDefArray, d2)
-	var d ChannelDef
-	d.Name = plugin.CLIPRDR_SVC_CHANNEL_NAME
-	d.Options = uint32(CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_ENCRYPT_RDP |
-		CHANNEL_OPTION_COMPRESS_RDP | CHANNEL_OPTION_SHOW_PROTOCOL)
-	n.ChannelDefArray = append(n.ChannelDefArray, d)
+	n.ChannelDefArray = append(n.ChannelDefArray, d2)*/
 
 	return n
 }
 
-func (d *ClientNetworkData) Pack() []byte {
+func (n *ClientNetworkData) AddVirtualChannel(name string, option uint32) {
+	var d ChannelDef
+	d.Name = name
+	d.Options = option
+	n.ChannelDefArray = append(n.ChannelDefArray, d)
+	n.ChannelCount++
+}
+
+func (n *ClientNetworkData) Pack() []byte {
 	buff := &bytes.Buffer{}
 	core.WriteUInt16LE(CS_NET, buff) // type
-	length := uint16(d.ChannelCount*12 + 8)
+	length := uint16(n.ChannelCount*12 + 8)
 	core.WriteUInt16LE(length, buff) // len 8
-	core.WriteUInt32LE(d.ChannelCount, buff)
-	for i := 0; i < int(d.ChannelCount); i++ {
-		v := d.ChannelDefArray[i]
+	core.WriteUInt32LE(n.ChannelCount, buff)
+	for i := 0; i < int(n.ChannelCount); i++ {
+		v := n.ChannelDefArray[i]
 		name := make([]byte, 8)
 		copy(name, []byte(v.Name))
 		core.WriteBytes(name[:], buff)
@@ -571,9 +570,6 @@ func ReadConferenceCreateResponse(data []byte) []interface{} {
 		return ret
 	}
 
-	glog.Debug("all:", SC_CORE, SC_SECURITY, SC_NET,
-		CS_CORE, CS_SECURITY, CS_NET, CS_CLUSTER, CS_MONITOR)
-
 	ln, _ := per.ReadLength(r)
 	for ln > 0 {
 		t, _ := core.ReadUint16LE(r)
@@ -601,7 +597,6 @@ func ReadConferenceCreateResponse(data []byte) []interface{} {
 			}
 			ret = append(ret, d)
 		}
-		glog.Debugf("d:%+v", d)
 	}
 
 	return ret
diff --git a/protocol/t125/mcs.go b/protocol/t125/mcs.go
index 35cb425..25da99e 100644
--- a/protocol/t125/mcs.go
+++ b/protocol/t125/mcs.go
@@ -8,6 +8,11 @@ import (
 	"io"
 	"reflect"
 
+	"github.com/tomatome/grdp/plugin/cliprdr"
+	"github.com/tomatome/grdp/plugin/rail"
+
+	"github.com/tomatome/grdp/plugin/drdynvc"
+
 	"github.com/tomatome/grdp/core"
 	"github.com/tomatome/grdp/emission"
 	"github.com/tomatome/grdp/glog"
@@ -272,16 +277,32 @@ func NewMCSClient(t core.Transport) *MCSClient {
 	return c
 }
 
-func (c *MCSClient) SetClientCoreData(width, height uint16) {
+func (c *MCSClient) SetClientDesktop(width, height uint16) {
 	c.clientCoreData.DesktopWidth = width
 	c.clientCoreData.DesktopHeight = height
 }
 
+func (c *MCSClient) SetClientDynvcProtocol() {
+	c.clientCoreData.EarlyCapabilityFlags = gcc.RNS_UD_CS_SUPPORT_DYNVC_GFX_PROTOCOL
+	c.clientNetworkData.AddVirtualChannel(drdynvc.ChannelName, drdynvc.ChannelOption)
+}
+
+func (c *MCSClient) SetClientRemoteProgram() {
+	c.clientNetworkData.AddVirtualChannel(rail.ChannelName, rail.ChannelOption)
+}
+
+func (c *MCSClient) SetClientCliprdr() {
+	c.clientNetworkData.AddVirtualChannel(cliprdr.ChannelName, cliprdr.ChannelOption)
+}
+
 func (c *MCSClient) connect(selectedProtocol uint32) {
 	glog.Debug("mcs client on connect", selectedProtocol)
 	c.clientCoreData.ServerSelectedProtocol = selectedProtocol
 
-	// sendConnectInitial
+	glog.Debugf("clientCoreData:%+v", c.clientCoreData)
+	glog.Debugf("clientNetworkData:%+v", c.clientNetworkData)
+	glog.Debugf("clientSecurityData:%+v", c.clientSecurityData)
+	// sendConnectclientCoreDataInitial
 	userDataBuff := bytes.Buffer{}
 	userDataBuff.Write(c.clientCoreData.Pack())
 	userDataBuff.Write(c.clientNetworkData.Pack())
@@ -305,7 +326,7 @@ func (c *MCSClient) connect(selectedProtocol uint32) {
 }
 
 func (c *MCSClient) recvConnectResponse(s []byte) {
-	glog.Debug("mcs recvConnectResponse", hex.EncodeToString(s))
+	glog.Trace("mcs recvConnectResponse", hex.EncodeToString(s))
 	cResp, err := ReadConnectResponse(bytes.NewReader(s))
 	if err != nil {
 		c.Emit("error", errors.New(fmt.Sprintf("ReadConnectResponse %v", err)))
@@ -433,7 +454,7 @@ func (c *MCSClient) sendChannelJoinRequest(channelId uint16) {
 }
 
 func (c *MCSClient) recvData(s []byte) {
-	glog.Debug("msc on data recvData:", hex.EncodeToString(s))
+	glog.Trace("msc on data recvData:", hex.EncodeToString(s))
 
 	r := bytes.NewReader(s)
 	option, err := core.ReadUInt8(r)
@@ -476,7 +497,7 @@ func (c *MCSClient) recvData(s []byte) {
 		c.Emit("error", errors.New(fmt.Sprintf("mcs recvData get data error %v", err)))
 		return
 	}
-	glog.Debugf("mcs emit channel<%s>:%v", channelName, left)
+	glog.Debugf("mcs emit channel<%s>", channelName)
 	c.Emit("sec", channelName, left)
 }
 
@@ -531,7 +552,7 @@ func (c *MCSClient) Pack(data []byte, channelId uint16) []byte {
 	core.WriteUInt8(0x70, buff)
 	per.WriteLength(len(data), buff)
 	core.WriteBytes(data, buff)
-	glog.Debug("MCSClient write", channelId, ":", hex.EncodeToString(buff.Bytes()))
+	glog.Trace("MCSClient write", channelId, ":", hex.EncodeToString(buff.Bytes()))
 	return buff.Bytes()
 }
 
diff --git a/protocol/tpkt/tpkt.go b/protocol/tpkt/tpkt.go
index 95c1a1c..12bd20c 100644
--- a/protocol/tpkt/tpkt.go
+++ b/protocol/tpkt/tpkt.go
@@ -75,7 +75,7 @@ func (t *TPKT) StartNLA() error {
 }
 
 func (t *TPKT) recvChallenge(data []byte) error {
-	glog.Debug("recvChallenge", hex.EncodeToString(data))
+	glog.Trace("recvChallenge", hex.EncodeToString(data))
 	tsreq, err := nla.DecodeDERTRequest(data)
 	if err != nil {
 		glog.Info("DecodeDERTRequest", err)
@@ -108,13 +108,13 @@ func (t *TPKT) recvChallenge(data []byte) error {
 }
 
 func (t *TPKT) recvPubKeyInc(data []byte) error {
-	glog.Debug("recvPubKeyInc", hex.EncodeToString(data))
+	glog.Trace("recvPubKeyInc", hex.EncodeToString(data))
 	tsreq, err := nla.DecodeDERTRequest(data)
 	if err != nil {
 		glog.Info("DecodeDERTRequest", err)
 		return err
 	}
-	glog.Debug("PubKeyAuth:", tsreq.PubKeyAuth)
+	glog.Trace("PubKeyAuth:", tsreq.PubKeyAuth)
 	//ignore
 	//pubkey := t.ntlmSec.GssDecrypt([]byte(tsreq.PubKeyAuth))
 	domain, username, password := t.ntlm.GetEncodedCredentials()
@@ -140,7 +140,7 @@ func (t *TPKT) Write(data []byte) (n int, err error) {
 	core.WriteUInt8(0, buff)
 	core.WriteUInt16BE(uint16(len(data)+4), buff)
 	buff.Write(data)
-	glog.Debug("tpkt Write", hex.EncodeToString(buff.Bytes()))
+	glog.Trace("tpkt Write", hex.EncodeToString(buff.Bytes()))
 	return t.Conn.Write(buff.Bytes())
 }
 
@@ -157,12 +157,12 @@ func (t *TPKT) SendFastPath(secFlag byte, data []byte) (n int, err error) {
 	core.WriteUInt8(FASTPATH_ACTION_FASTPATH|((secFlag&0x3)<<6), buff)
 	core.WriteUInt16BE(uint16(len(data)+3)|0x8000, buff)
 	buff.Write(data)
-	glog.Debug("TPTK SendFastPath", hex.EncodeToString(buff.Bytes()))
+	glog.Trace("TPTK SendFastPath", hex.EncodeToString(buff.Bytes()))
 	return t.Conn.Write(buff.Bytes())
 }
 
 func (t *TPKT) recvHeader(s []byte, err error) {
-	glog.Debug("tpkt recvHeader", hex.EncodeToString(s), err)
+	glog.Trace("tpkt recvHeader", hex.EncodeToString(s), err)
 	if err != nil {
 		t.Emit("error", err)
 		return
@@ -185,7 +185,7 @@ func (t *TPKT) recvHeader(s []byte, err error) {
 }
 
 func (t *TPKT) recvExtendedHeader(s []byte, err error) {
-	glog.Debug("tpkt recvExtendedHeader", hex.EncodeToString(s), err)
+	glog.Trace("tpkt recvExtendedHeader", hex.EncodeToString(s), err)
 	if err != nil {
 		return
 	}
@@ -196,7 +196,7 @@ func (t *TPKT) recvExtendedHeader(s []byte, err error) {
 }
 
 func (t *TPKT) recvData(s []byte, err error) {
-	glog.Debug("tpkt recvData", hex.EncodeToString(s), err)
+	glog.Trace("tpkt recvData", hex.EncodeToString(s), err)
 	if err != nil {
 		return
 	}
@@ -205,7 +205,7 @@ func (t *TPKT) recvData(s []byte, err error) {
 }
 
 func (t *TPKT) recvExtendedFastPathHeader(s []byte, err error) {
-	glog.Debug("tpkt recvExtendedFastPathHeader", hex.EncodeToString(s))
+	glog.Trace("tpkt recvExtendedFastPathHeader", hex.EncodeToString(s))
 	r := bytes.NewReader(s)
 	rightPart, err := core.ReadUInt8(r)
 	if err != nil {
@@ -219,7 +219,7 @@ func (t *TPKT) recvExtendedFastPathHeader(s []byte, err error) {
 }
 
 func (t *TPKT) recvFastPath(s []byte, err error) {
-	glog.Debug("tpkt recvFastPath")
+	glog.Trace("tpkt recvFastPath")
 	if err != nil {
 		return
 	}
diff --git a/protocol/x224/x224.go b/protocol/x224/x224.go
index f147b52..b81051e 100644
--- a/protocol/x224/x224.go
+++ b/protocol/x224/x224.go
@@ -70,6 +70,28 @@ func NewNegotiation() *Negotiation {
 	return &Negotiation{0, 0, 0x0008 /*constant*/, PROTOCOL_RDP}
 }
 
+type failureCode int
+
+const (
+	//The server requires that the client support Enhanced RDP Security (section 5.4) with either TLS 1.0, 1.1 or 1.2 (section 5.4.5.1) or CredSSP (section 5.4.5.2). If only CredSSP was requested then the server only supports TLS.
+	SSL_REQUIRED_BY_SERVER = 0x00000001
+
+	//The server is configured to only use Standard RDP Security mechanisms (section 5.3) and does not support any External Security Protocols (section 5.4.5).
+	SSL_NOT_ALLOWED_BY_SERVER = 0x00000002
+
+	//The server does not possess a valid authentication certificate and cannot initialize the External Security Protocol Provider (section 5.4.5).
+	SSL_CERT_NOT_ON_SERVER = 0x00000003
+
+	//The list of requested security protocols is not consistent with the current security protocol in effect. This error is only possible when the Direct Approach (sections 5.4.2.2 and 1.3.1.2) is used and an External Security Protocol (section 5.4.5) is already being used.
+	INCONSISTENT_FLAGS = 0x00000004
+
+	//The server requires that the client support Enhanced RDP Security (section 5.4) with CredSSP (section 5.4.5.2).
+	HYBRID_REQUIRED_BY_SERVER = 0x00000005
+
+	//The server requires that the client support Enhanced RDP Security (section 5.4) with TLS 1.0, 1.1 or 1.2 (section 5.4.5.1) and certificate-based client authentication.<4>
+	SSL_WITH_USER_AUTH_REQUIRED_BY_SERVER = 0x00000006
+)
+
 /**
  * X224 client connection request
  * @param opt {object} component type options
@@ -179,7 +201,7 @@ func (x *X224) Write(b []byte) (n int, err error) {
 	}
 	buff.Write(b)
 
-	glog.Debug("x224 write:", hex.EncodeToString(buff.Bytes()))
+	glog.Trace("x224 write:", hex.EncodeToString(buff.Bytes()))
 	return x.transport.Write(buff.Bytes())
 }
 
@@ -266,7 +288,7 @@ func (x *X224) recvConnectionConfirm(s []byte) {
 }
 
 func (x *X224) recvData(s []byte) {
-	glog.Debug("x224 recvData", hex.EncodeToString(s), "emit data")
+	glog.Trace("x224 recvData", hex.EncodeToString(s), "emit data")
 	// x224 header takes 3 bytes
 	x.Emit("data", s[3:])
 }
